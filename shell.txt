#!/bin/sh

cd ~

mkdir shell_tut

cd shell_tut

 

for ((i=0; i<10; i++)); do

        touch test_$i.txt

done
·第1行：指定脚本解释器，这里是用/bin/sh做解释器的
·第2行：切换到当前用户的home目录
·第3行：创建一个目录shell_tut
·第4行：切换到shell_tut目录
·第5行：循环条件，一共循环10次
·第6行：创建一个test_1…10.txt文件
·第7行：循环体结束

只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了
在CentOS里，/bin/sh是一个指向/bin/bash的符号链接:
Mac OS上不是，/bin/sh和/bin/bash是两个不同的文件，尽管它们的大小只相差100字节左右:

PHP Shell Script示例（假设文件名叫test.php）：

复制代码
#!/usr/bin/php

<?php

for ($i=0; $i < 10; $i++)

        echo $i . "\n";

执行：

/usr/bin/php test.php

或者：

chmod +x test.php

./test.php

输入一些代码，第一行一般是这样：

复制代码
#!/bin/bash

#!/usr/bin/php

“#!”是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行。
运行Shell脚本有两种方法：
		chmod +x test.sh

		./test.sh
一定要写成./test.sh，而不是test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin, /usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。

定义变量时，变量名不加美元符号（$），如：
	your_name="qinjx"
		变量名和等号之间不能有空格

除了显式地直接赋值，还可以用语句给变量赋值，如：
	for file in `ls /etc`

使用一个定义过的变量，只要在变量名前面加美元符号即可，如：
	your_name="qinjx"
	echo $your_name
	echo ${your_name}

变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：
	for skill in Ada Coffe Action Java; do
			echo "I am good at ${skill}Script"
	done
不给skill变量加花括号，写成echo "I am good at $skillScript"，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。
所有变量加上花括号，这是个好的编程习惯

定义的变量，可以被重新定义
	your_name="qinjx"
	echo $your_name
	your_name="alibaba"
	echo $your_name
第二次赋值的时候不能写$your_name="alibaba"，使用变量的时候才加美元符。

以“#”开头的行就是注释，会被解释器忽略。

每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。

字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了，哈哈），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。

单引号
	单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的
	·单引号字串中不能出现单引号（对单引号使用转义符后也不行）

双引号
	your_name='qinjx'
	str="Hello, I know your are \"$your_name\"! \n"
	·双引号里可以有变量
	·双引号里可以出现转义字符	

拼接字符串=====
	your_name="qinjx"
	greeting="hello, "$your_name" !"
	greeting_1="hello, ${your_name} !"
	echo $greeting $greeting_1
	
获取字符串长度：
	string="abcd"
	echo ${#string} #输出：4
	
提取子字符串
	string="alibaba is a great company"
	echo ${string:1:4} #输出：liba
	
查找子字符串=====
	string="alibaba is a great company"
	echo `expr index "$string" is`#输出：8，这个语句的意思是：找出单词is在这名话中的位置
	
	
sh的流程控制不可为空，如：
	<?php
	if (isset($_GET["q"])) {
			search(q);
	}
	else {
			//do nothing
	}
在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else。

sh里的if [ $foo -eq 0 ]，这个方括号跟Java/PHP里if后面的圆括号大不相同，它是一个可执行程序（和cd, ls, grep一样），想不到吧？在CentOS上，它在/usr/bin目录下：

	ll /usr/bin/[

	-rwxr-xr-x. 1 root root 33408 6月  22 2012 /usr/bin/[
正因为方括号在这里是一个可执行程序，方括号后面必须加空格，不能写成if [$foo -eq 0]

if else
if
if condition
then
        command1
        command2
        ...
        commandN
fi

写成一行（适用于终端命令提示符）：
	if `ps -ef | grep ssh`;  then echo hello; fi
末尾的fi就是if倒过来拼写，后面还会遇到类似的

if else
if condition
then
        command1
        command2
        ...
        commandN
else
        command
fi
if else-if else
if condition1
then
        command1
elif condition2
        command2
else
        commandN
fi
for while
for
在开篇的示例里演示过了：
for var in item1 item2 ... itemN
do
        command1
        command2
        ...
        commandN
done

写成一行：
for var in item1 item2 ... itemN; do command1; command2… done;


C风格的for
for (( EXP1; EXP2; EXP3 ))
do
        command1
        command2
        command3
done

while
while condition
do

        command

done

无限循环
while :
do
        command
done

或者
while true
do

        command

done
或者
for (( ; ; ))
until
until condition
do
        command
done

case
case "${opt}" in
        "Install-Puppet-Server" )

                install_master $1

                exit

        ;;
        "Install-Puppet-Client" )

                install_client $1

                exit

        ;;
        "Config-Puppet-Server" )

                config_puppet_master

                exit

        ;;
        "Config-Puppet-Client" )

                config_puppet_client

                exit

        ;;
        "Exit" )
                exit
        ;;
        * ) echo "Bad option, please choose again"
esac

case的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break

函数
定义
调用
文件包含

可以使用source和.关键字，如：
	source ./function.sh
	. ./function.sh
	
在bash里，source和.是等效的，他们都是读入function.sh的内容并执行其内容（类似PHP里的include），为了更好的可移植性，推荐使用第二种写法。
包含一个文件和执行一个文件一样，也要写这个文件的路径，不能光写文件名，比如上述例子中:
	. ./function.sh
不可以写作：
	. function.sh

如果function.sh是用户传入的参数，如何获得它的绝对路径呢？方法是：
	real_path=`readlink -f $1`#$1是用户输入的参数，如function.sh
	. $real_path

用户输入
执行脚本时传入
脚本运行中输入
select菜单
stdin和stdout
常用的命令
sh脚本结合系统命令便有了强大的威力，在字符处理领域，有grep、awk、sed三剑客，grep负责找出特定的行，awk能将行拆分成多个字段，sed则可以实现更新插入删除等写操作。

ps
查看进程列表

grep
排除grep自身
查找与target相邻的结果